package kr.ac.kopo.day05;

// 배열의 크기는 선언된이후 중간에 크기를 수정할 수 없다. 즉, 배열의 크기는 이런점에서 고정된 것이다.
// 2차원 배열은 1차원 배열을 모아놓은 집합이다. 3차원 배열은 2차원 배열을 모아놓은 집합이다.
// 2차원 배열이라는 의미는 1차원 배열의 주소값을 갖고 있는 배열을 생성하는 것이다.
// 2차원 배열에서 [][] 2번의 대괄호의 의미는 arr 이라는 2차원 배열의 변수를 통해서 2번 주소값을 접근하게되면
// 비로소 실제 데이터값이 접근할 수 있음을 의미하는 것이다.




public class ArrayMain06 {
	
	public static void main(String[] args) {
		
//		int[][] arr = new int[3][];
		
		// 위의 코드의 의미는 1차원 배열을 3개 모아 놓은 2차원 배열을 만들고 싶다는 의미이다.
		
		int[][] arr = new int[3][4];

		// 위의 코드의 의미는 1차원 배열을 3개 모아 놓은 2차원 배열을 만들고 싶은데, 각각의 1차원 배열은
		// int형의 데이터를 4개 가질 수 있는 구조라는 것이고, 반드시 4개의 int 데이터를 가져야한다는 것이다.
		// int[3][4]에서 int[3]만 분리해서 보면, 
		
		System.out.println("arr : " + arr + ", arr.length : " + arr.length);
		
		for(int i = 0; i < arr.length; i++) {
			
			System.out.println("arr[" + i + "] : " + arr[i]);
			
		}
		
		// arr.length의 결과는 주소값이 도출되고, arr[1].length의 결과값도 주소값이 찍힌다.
		// arr[1].length 의 결과값은 4가 도출되는데, 이 의미는 arr[1]은 int형 1차원 배열의 주소를 담고있고,
		// 결과적으로 length 메소드를 적용하면, arr[1] 변수가 담고있는 주소가 가리키고 있는 객체로 향해서,
		// 그 객체의 개수값을 도출해주는 것이다. 이것이 length메소드의 동작과정이다.
		
		
//		int[][] arr = new int[3][4];
		
		
//		int[] ar01 = new int[4];
//		int[] ar02 = new int[4];
//		int[] ar03 = new int[4];
//		int[][] arr = {ar01, ar02, ar03};
		
		// 위의 코드는 정확히 동일한 의미이다.
		// new가 본질적으로 4번이 사용된 것이므로, 힙영역에 4개의 객체가 생성된 것이다.
		// ar01,02,03이나 arr의 공통적인 목적은 모두 int형의 데이터에 접근하려는 것이다.
		// ar01의 경우는 []한쌍이므로, ar01 변수가 갖고 있는 주소 값을 이용해서 한번만 접근하면 
		// 데이터에 접근할 수 있음을 의미하고, arr의 경우는 [][] 두쌍이므로, arr 변수가 갖고 있는 주소값을
		// 이용해서 두번의 과정으로 접근하면 int 형 데이터에 접근할 수 있음을 의미한다.
		
		for(int i = 0; i < arr[0].length; i++) {
			
			arr[0][i] = (i+1) * 10;
			
		}
		
		for(int i = 0; i < arr.length; i++) {
			
			for(int j = 0; j < arr[i].length; j++) {
				
				System.out.print(arr[i][j] + "\t");
				
			}
			
			System.out.println();
			
		}
		
	}
	
}

// 2차원 배열은 본질적으로 1차원 배열이 길어질 경우 각각의 요소에 좀더 효과적으로 접근하기 위해 만들어진 개념이다.

