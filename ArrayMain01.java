package kr.ac.kopo.day04;

// 배열이란 "같은 타입의 변수"를 연속적인 공간에 저장할 수 있게 하는 고정된 크기를 갖는 자료구조(집합)
// 배열은 사용자가 변수를 일일이 선언하는 것에 대한 번거로움을 줄이기 위해서 나온 것이다.
// 데이터를 효율적으로 저장할 수 있는 방법론을 구분지어놓은 것을 자료구조하고 한다.
// 비전공자와 전공자의 가장큰 자이는 용어에 대한 익숙도 뿐이다. 그래서 비전공자라면 전공자와 관련된 책을 많이 읽어야한다.
// 이산수학, 데이터통신, 네트워크 정도는 알아야한다.
// 컴퓨터에 대한 용어가 약하면 어렵게 느껴지게된다.
// 컴퓨터가 변수와 변수를 구분할 수 있는 것은 변수의 이름이 아니라 변수가 저장된 시작 주소값을통해 구분한다.
// int a,b,c,d 와 같이 변수가 여러개가 정의됐을 경우 컴퓨터는 변수의 주소를  a,b,c,d 변수 각각에 대해서도 저장하고
// 있어야 하므로, 저장공간의 차원에서 비효율적이다. 그러므로, 배열이 등장하게 됐다. 즉, a,b,c,d 변수의 저장공간을 하나로
// 합친 저장공간을 만든 것과도 같은 것이 배열이다.
// 이러한 배열도 배열의 이름과 함께 배열이 저장된 공간의 시작주소값도 존재한다.
// 배열의 핵심적인 역할을 배열이 저장하고 있는 같은타입의 변수를 사용자가 효율적으로 접근할 수 있도록 하는 것인데,
// 변수는 저장된 시작주소값을 가지므로 배열이 저장하고 있는 변수 또한 시작주소값을 가진다. 
// 또한, 배열은 같은 타입의 변수를 연속적으로 저장해놓은 저장공간이므로 배열의 첫번째 변수의 시작주소값을 알기만 하면,
// 배열안의 변수는 연속적으로 저장되어있으므로, 배열안의 데이터의 시작주소값을 도출할 수 있다.
// 배열이라는 저장공간은 항상 같은타입의 변수를 연속적으로 저장하고 있다.

// 배열을 선언할 때, 배열의 크기를 정의하는 순간 그 크기는 다시 수정할 수 없다. 즉, 배열은 항상 저장할 수 있는 변수의 크기가
// 고정되어있다.

// 메모리는 스택과 힙이 존재하는데 스택의 크기는 고정적이지만, 힙의 크기는 고정적이지 않다. 스택의 크기가 고정적이므로
// 배열을 스택에 저장하면 스택의 공간이 부족해져간다. 그러므로, 힙에 배열을 저장하게 된다.

// 힙에 만들어진 저장공간을 객체라고 할 수 있다. 즉, new라는 명령어를 통해 만들어진 모든 것은 힙에 저장되므로,
// new를 통해 만들어진 모든 힘에 저장된 것을 객체라고 할 수 있다.

// 배열은 같은타입의 변수가 연속적으로 저장되어있으므로, 변수가 존재하는 공간의 시작주소의 위치값을 통해서 변수에 접근할 수 있지만,
// 같은 타입의 변수가 연속적으로 존재하고 있으므로, 같은 타입의 변수가 첫번째 변수로 부터 몇번째 위치에 존재하고 있는지를 
// 통해서도 변수의 위치를 정확히 나타낼 수 있다.

// 배열의 크기는 정의할 때 정해지므로, 크기가 고정적이지 않다. 그러므로, 배열은 고정된 크기를 갖지 않으므로, 배열은
// 스택이 아닌 힙에 저장공간을 형성하여 저장하게된다. 즉, 배열은 힙에 저장되어야 하므로 new라는 메소드를 통해서 생성한다.
// new라는 메소드를 사용하면 힙에 어떠한 데이터를 저장할 수 있는 저장공간이 생성되는데 이 저장공간 자체가 객체라고 할 수 있다.

// 또한, 힙의 저장공간에 형성된 배열에 접근하기 위해서는 저장된 배열의 시작주소값이 필요한데, 시작주소는 스택에 저장되어있다.

// double[] aaa 의 의미는 aaa라는 이름을 갖는 배열 변수는 double 타입의 배열의 시작주소를 기억하고 있다는 의미이다.
// 그리고 = 뒤의 new double[]의 의미는 double라는 타입의 변수를 저장할 수 있는 저장공간인 배열을 heap에 저장공간을
// 만들어서 형성한다는 의미이다.
// double[] 은 구분지어서 생각할 것이 아니라, 함께 묶여있는 것으로 인식해서 2개가 합쳐진 하나의 자료형으로 인식할 수 있다.
// 즉, double[] aaa의 의미는 aaa라는 이름을 갖는 변수는 "double형의 데이터를 연속적으로 갖는 배열인 자료형이다" 라는
// 의미를 표현하고, "double 형의 데이터를 연속적으로 갖는 배열의 이름은 aaa인데 aaa는 이 배열의 시작주소 값을 저장하고 있는
// 변수임을 나타낸다.
// double[][] aaa와 같은 2차원 배열도 동일은 의미를 갖는다. 즉 aaa는 double의 데이터를 연속적으로 저장하고 있는
// 배열의 시작주소값을 저장하고 있는 변수이다라는 것이다. 즉, 표현되기에는 배열의 표현이 되어있지만, 실제로는 배열의 
// 주소값만 기억하고 있는 표현이 double[][] aaa가 나타내고 있는 본질적인 의미이다. 이후 실제 값을 이 aaa변수에 
// 저장하겠다는 의미를 new 라는 메소드를 이용해서 new 배열유형[배열크기] 와 같은 표현으로 정의를 해줘야 비로소
// 배열의 주소값을 저장하고 있는 공간과 실제 배열의 데이터를 저장할 수 있는 공간이 스택과 힙에 각각 생성되어 배열이 
// 비로소 정의되는 것이다.
// 따라서, 모든 객체는 객체의 이름과 시작주소의 값, 그리고 실제 저장하고 있는 데이터를 갖고 있으므로, 모든 객체는
// 본질적으로 위와 같은 문법으로 정의하게 되는 것이다.

// new라는 메소드를 통해 만들어지는 힙영역의 저장공간은 항상 저장공간에 설정되는 기본값을 갖는다. 이 기본값은 생성되는
// 저장공간이 생성되자 마자 설정되는 것으로 초기화값이라고 한다.



// 크기가 100개인 배열에 대해서도 위치값을 저장하고 있는 변수는 배열의 시작주소많을 저장하고 있다.

// 모든객체생성의 본질 ==> 자료형 변수형 = new 자료형() 모든 객체는 이러한 구조적 본질로 생성되게된다.

// 힙에 저장된 객체의 시작주소값을 기억하고있는 변수이름을 알면 시작주소값을 알고, 그 시작 주소값으로부터 일정한 1의 거리
// 만큼 떨어져 있는 변수, 2의 거리만큼 상대적으로 떨어져 있는 변수 ~ 를 생각할 수 있는데, 
// 이러한 개념을 통해 배열의 변수에 접근할 수 있다. 이때 객체가 저장된 시작주소의 값으로부터 상대적인 위치값을 인덱스라고 한다.

// 배열의 크기를 자유롭게 정의할 수 있다는 점에서 가변성이 있지만, 한번 정의되고나면 배열의 크기를 수정할 순없다.

// 형변환 이라는 것은 본질적인 나의 자료형이 변하는 것은 아니다.형변환을 시키면 본질은 그대로 있지만, 일시적으로 
// 내가 원하는 자료형으로 인식하고자 하겠다는 것이다.

// int[] prime = new int[5]; 
// int[] prime = new int[7];

// 이와 같이 정의되어있을 때, prime이라는 int형 자료형을 5개 저장하는 배열이 prime이라는 변수가 이제 7개 저장하는
// 배열을 가리키게 되는 상황으로 변하게 된다. 그리고, 기존의 크기가 5개의 배열의 공간은 그 어떤 시작주소값을 저장하고있는
// 변수도 int[5] 배열 공간을 가리키고 있지 않게 되는데, 이때 이 공간을 가비지 공간이라고 한다. 또한, 이경우 prime변수에
// 저장되어 있는 배열의 시작주소값 또한 가리키는 저장공간의 위치가 바뀌었으므로 바뀌게 된다.

// 참조자료형으로 만들어진 저장공간에 할당되는 기본값, 즉 초기화 값은 null값이 할당된다.
// 기본자료형중 int로 만들어진 배열은 int[] prime = new int[4]; 로형성된 배열은 생성되자마자 prime[0]의 값은
// 초기화값인 0으로 도출되게된다.

// 배열은 항상 new통해서만 만들 수 있다.


public class ArrayMain01 {
	
	public static void main(String[] args) {
		
		int[] arr;

		arr = new int[5];
		
//		System.out.println("arr : " + arr);
		
		// new로생성된 객체만이 자동초기화가 일어난다.
		// 그러므로, 위의 경우의 new가 없다고 생각했을때, arr객체는 초기화가돼있지 않으므로, 위처럼 변수가 
		// 가리키고 있는 저장공간의 시작 주소값이 출력되지 않는다.
				
		System.out.println("arr : " + arr);
		
		// 이경우엔 주소값이 찍히게 된다.
		
		arr = new int[10];
		
		System.out.println("arr : " + arr);
		
		// 같은 arr변수이지만, 주소값은 다르다. 왜냐면 arr변수가 가리키고 있는 힙영역의 배열의 저장공간이 다르기 때문이다.
		
		// for문에서 변수 i를 주로 쓰는 이유는 i가 일반적으로 인덱스 i를 의미하기 때문이다.그리고 인덱스는
		// 0부터 시작하기 때문에 초기값을 일반적으로 0으로 설정하게된다.
		// 또한 크기가 5인 배열의 경우 아래와 같이 참거짓조건을 5보다 작다의 의미로 표현한다.
		// 그리고,
		
		// for(int i = 0; i < arr.length; i++) 와 같이 표현하기도 한다.
		
		for(int i = 0; i < 5; i++) {
			
			System.out.println(i + "번째 원소 : " + arr[i]);
			
		}
		
		// 각 원소값에 10, 20, 30, 40, 50을 대입하는 경우
		
		for(int i = 0; i < arr.length; i++) {
			
			arr[i] = (i+1) * 10;
			
		}
	
	}
	
}
